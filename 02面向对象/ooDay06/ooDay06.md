# 面向对象第六天：

## 潜艇游戏第一天：

1. 设计6个类，设计World类并测试

## 潜艇游戏第二天：

1. 给6个类添加构造方法，并测试

## 潜艇游戏第三天：

1. 设计SeaObject超类，6个类继承SeaObject
2. 给SeaObject设计两个构造方法，6个派生类分别调用
3. 设计潜艇数组、水雷数组、深水炸弹数组，并测试

## 潜艇游戏第四天：

1. 在6个类中重写move()移动
2. 给类中成员添加访问控制修饰符
3. 设计Images图片类

## 潜艇游戏第五天：

1. 将窗口的宽和高设计为常量，适当地方做修改

2. 画窗口：在World类中---共3步，不要求掌握，Ctrl C/V

   - import JFrame和JPanel
   - 设计World类继承JPanel
   - CV大法

3. 画海洋图、画对象

   ```java
   1)想画对象需要去获取对象的图片，每个对象都能获取图片，
     意味着获取图片行为为共有的行为，所以设计在SeaObject中，
     每个对象获取图片的行为都是不一样的，所以设计为抽象方法
     ----在SeaObject中设计getImage()获取对象的图片
   2)在6个派生类中重写getImage()获取对象的图片
     ----重写getImage()
   3)因为只有活着的对象才需要画到窗口中，所以需要设计对象的状态，
     每个对象都有状态，意味着状态为共有属性，所以设计在SeaObject中，
     状态一般设计为常量，同时设计state变量表示当前状态
     ----在SeaObject中设计LIVE、DEAD常量，state变量表示当前状态
     后期的业务中还需要判断状态，每个对象都得判断状态，
     意味着判断状态行为为共有的行为，所以设计在SeaObject中，
     每个对象判断状态的行为都是一样的，所以设计为普通方法
     ----在SeaObject中设计isLive()、isDead()判断对象的状态
   4)数据都有了就可以开画了，每个对象都能画，
     意味着画对象的行为为共有行为，所以设计在SeaObject中，
     每个对象画的行为都是一样的，所以设计为普通方法
     ----在SeaObject中设计paintImage()画对象
   5)画对象的行为做好了，在窗口World中调用即可:
     5.1)准备对象
     5.2)重写paint()画方法  
   ```

## 潜艇游戏第六天：

1. 潜艇入场：

   - 潜艇对象是由窗口产生的，所以在World类中设计nextSubmarine()生成潜艇对象

   - 潜艇入场为定时发生的，所以在run()中调用submarineEnterAction()实现潜艇入场

     在submarineEnterAction()中：

     ​	每400毫秒，获取潜艇对象obj，submarines扩容，将obj装到末尾

     > 注意: 在run中调用submarineEnterAction()后，调用repaint()重画

2. 水雷入场：

   - 水雷是由水雷潜艇发射出来的，所以在MineSubmarine中shootMine()生成水雷对象

   - 水雷入场为定时发生的，所以在run()中调用mineEnterAction()实现水雷入场

     在mineEnterAction()中：

     ​	每1秒钟，......(暂时搁置，周三时讲)

3. 海洋对象移动：

   - 海洋对象移动为共有的行为，所以在SeaObject中设计抽象方法move()实现海洋对象移动，在派生类重写move()

   - 海洋对象移动为定时发生的，所以在run()中调用moveAction()实现海洋对象移动

     在moveAction()中：

     ​	遍历所有潜艇潜艇move()，遍历所有水雷水雷move()，遍历所有深水炸弹深水炸弹move()

     ​	

     

## 回顾：

1. final：最终的，不可改变的

   ​	变量不能被改变、方法不能被重写、类不能被继承

2. static final常量：

   ​	必须声明同时初始化，由类名点来访问，不能被改变，大写

   ​	编译器在编译时会将常量直接替换为具体的值，效率高

   ​	数据永远不变，并且经常使用

3. 抽象方法：

   ​	abstract，只有方法的定义，没有具体的实现(连{}都没有)

4. 抽象类：

   ​	abstract，包含抽象方法的类必须是抽象类，不能被实例化

   ​	需要被继承，派生类：必须重写所有抽象方法----变不完整为完整

   ​	意义：代码复用、向上造型、可以包含抽象方法，为所有派生类提供统一的入口(能点出来)，强制必须重写(制定了一个标准)



## 笔记：

1. 成员内部类：应用率低，了解

   - 类中套类，外面的称为外部类，里面的称为内部类
   - 内部类通常只服务于外部类，对外不具备可见性
   - 内部类对象只能在外部类中创建
   - 内部类中可以直接访问外部类的成员(包括私有的)，在内部类中有个隐式的引用指向了创建它的外部类对象------外部类名.this

   ```java
   public class InnerClassDemo {
       public static void main(String[] args) {
           Mama m = new Mama();
           //Baby b = new Baby(); //编译错误，内部类对外不具备可见性
       }
   }
   
   class Mama{ //外部类
       private String name;
       Baby b = new Baby(); //内部类对象通常在外部类中创建
       class Baby{ //内部类
           void show(){
               System.out.println(name);
               System.out.println(Mama.this.name); //Mama.this指代它的外部类对象
           }
       }
   }
   ```

2. 匿名内部类：应用率高-----------------大大简化代码

   - 若想创建一个类(派生类)的对象，并且对象只创建一个，此时该类不必命名，称为匿名内部类
   - 匿名内部类中不能修改外面变量的值，因为在此处该变量默认为final的

   ```java
   public class AnonInnerClassDemo {
       public static void main(String[] args) {
           //1)创建了Aoo的一个派生类，但是没有名字
           //2)为该派生类创建了一个对象，名为o1
           //3)大括号中的为派生类的类体
           Aoo o1 = new Aoo(){
           };
   
           //1)创建了Aoo的一个派生类，但是没有名字
           //2)为该派生类创建了一个对象，名为o2
           //3)大括号中的为派生类的类体
           Aoo o2 = new Aoo(){
           };
   
   
           int num = 5;
           num = 55;
           //1)创建了Boo的一个派生类，但是没有名字
           //2)为该派生类创建了一个对象，名为o3
           //3)大括号中的为派生类的类体
           Boo o3 = new Boo(){
               void show(){
                   System.out.println("showshow");
                   //num = 66; //编译错误，匿名内部类中不能修饰外面变量的值，因为在此处默认为final的
               }
           };
           o3.show();
       }
   }
   
   abstract class Boo{
       abstract void show();
   }
   
   abstract class Aoo{
   }
   ```



## 精华笔记:

1. 成员内部类：应用率低，了解

   - 类中套类，外面的称为外部类，里面的称为内部类
   - 内部类通常只服务于外部类，对外不具备可见性
   - 内部类对象只能在外部类中创建
   - 内部类中可以直接访问外部类的成员(包括私有的)，在内部类中有个隐式的引用指向了创建它的外部类对象------外部类名.this

2. 匿名内部类：应用率高-----------------大大简化代码

   - 若想创建一个类(派生类)的对象，并且对象只创建一个，此时该类不必命名，称为匿名内部类
   - 匿名内部类中不能修改外面变量的值，因为在此处该变量默认为final的






补充：

1. 隐式对象：

   - this：当前对象
   - super：当前对象的超类对象
   - 外部类名.this：当前对象的外部类对象

2. 必须记住的，API中会用的：

   - 外部类名.this：指代当前对象的外部类对象
   - 匿名内部类不能修改外面变量的值，因为在此处默认为final的

3. 小面试题：

   - 问：内部类有独立的.class字节码文件吗？

     答：有

4. 做功能的套路：

   - 先写行为/方法：
     - 若为某对象所特有的行为，就将方法设计在特定的类中
     - 若为所有对象所共有的行为，就将方法设计在超类中
   - 窗口调用：
     - 若为定时发生的，就在定时器中调用
     - 若为事件触发的，就在侦听器中调用----------明天上午讲

5. 调错方式：

   - 打桩：System.out.println(数据);

# 面向对象第三天：

## 潜艇游戏第一天：

1. 设计6个类，设计World类并测试

## 潜艇游戏第二天：

1. 给6个类添加构造方法，并测试

## 潜艇游戏第三天：

1. 设计侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组、水雷数组、炸弹数组，并测试
2. 设计SeaObject超类，6个类继承SeaObject
3. 给SeaObject设计两个构造方法，6个派生类分别调用
4. 将侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组统一组合为SeaObject数组，并测试



## 回顾：

1. 构造方法：构造函数、构造器、构建器--------复用给成员变量赋值

   - 作用：给成员变量赋初值
   - 与类同名，没有返回值类型(连void)
   - 创建对象时被自动调用
   - 若自己不写构造，默认一个无参构造，若自己写了构造，则不再默认提供
   - 可以重载

2. this：指代当前对象，哪个对象调用方法它指的就是哪个对象

   this的用法：

     this.成员变量名-------------------------访问成员变量

   > 当成员变量与局部变量同名时，若想访问成员变量则this不能省略

3. null：表示空，没有指向任何对象

   ​          若引用的值为null，则该引用不能进行任何操作了，若操作则发生        NullPointerException空指针异常

4. 引用类型数组：

   ```java
   Bomb[] bs = new Bomb[3];
   bs[0] = new Bomb(100,200); //1)new
   bs[1] = new Bomb(200,300);
   bs[2] = new Bomb(300,400);
   System.out.println(bs[0].width); //2)访问属性需打点
   ```

   



## 笔记：

1. 引用类型数组：

   ```java
   1)Bomb[] bs = new Bomb[3];
     bs[0] = new Bomb(100,200);
     bs[1] = new Bomb(200,300);
     bs[2] = new Bomb(300,400);
     System.out.println(bs[0].width); //输出第1个炸弹的宽
     bs[1].x = 250; //修改第2个炸弹的x为250
     bs[2].move(); //第3个炸弹移动
     
     for(int i=0;i<bs.length;i++){ //遍历所有子弹
         System.out.println(bs[i].height); //输出每个子弹的高
         bs[i].move(); //每个子弹移动
     }
   2)Bomb[] bs = new Bomb[]{ //了解
         new Bomb(100,200),
         new Bomb(200,300),
         new Bomb(300,400)
     };
   ```

2. 继承：

   - 作用：代码复用

   - 通过extends来实现继承

   - 超类/父类：共有的属性和行为

     派生类/子类：特有的属性和行为

   - 派生类既能访问自己的，也能访问超类的，但超类不能访问派生类的

   - 一个超类可以有多个派生类

     一个派生类只能有一个超类-----------单一继承

   - 具有传递性

   - java规定：构造派生类之前必须先构造超类

     - 派生类的构造方法中若没有调用超类的构造方法，则默认super()调用超类的无参构造方法
     - 派生类的构造方法中若自己调用了超类的构造方法，则不再默认提供

     > super()调用超类构造方法，必须位于派生类构造方法的第一行

     ```java
     //super的演示
     public class SuperDemo {
         public static void main(String[] args) {
             Boo o = new Boo();
         }
     }
     class Coo{
         Coo(int a){
         }
     }
     class Doo extends Coo{
         Doo(){
             super(5); //调用超类的有参构造
         }
         /*
         //如下代码为默认的:
         Doo(){
             super();
         }
          */
     }
     
     class Aoo{
         Aoo(){
             System.out.println("超类构造");
         }
     }
     class Boo extends Aoo{
         Boo(){
             //super(); //默认的，调用超类的无参构造
             System.out.println("派生类构造");
         }
     }
     ```

3. super：指代当前对象的超类对象

   super的用法：

   - super.成员变量名----------------------访问超类的成员变量(了解)
   - super.方法名()---------------------------调用超类的方法----------明天讲
   - super()-------------------------------------调用超类的构造方法

4. 向上造型：---------------------代码复用

   - 超类型的引用指向了派生类的对象
   - 能点出来什么，看引用的类型-----------这是规定，记住就OK了

   ```java
   package ooday03;
   //向上造型的演示
   public class UploadDemo {
       public static void main(String[] args) {
           Eoo o1 = new Eoo();
           o1.a = 1;
           o1.show();
           //o1.b = 2;  //编译错误
           //o1.test(); //编译错误，超类不能访问派生类的
   
           Foo o2 = new Foo();
           o2.b = 1;
           o2.test();
           o2.a = 2;  //正确
           o2.show(); //正确，派生类可以访问超类的
   
           Eoo o3 = new Foo(); //向上造型
           o3.a = 1;
           o3.show();
           //o3.b = 2;  //编译错误
           //o3.test(); //编译错误，能点出来什么，看引用的类型
       }
   }
   
   class Eoo{
       int a;
       void show(){
       }
   }
   class Foo extends Eoo{
       int b;
       void test(){
       }
   }
   ```



## 精华笔记：

1. 引用类型数组：

2. 继承：

   - 作用：代码复用

   - 通过extends来实现继承

   - 超类/父类：共有的属性和行为

     派生类/子类：特有的属性和行为

   - 派生类既能访问自己的，也能访问超类的，但超类不能访问派生类的

   - 一个超类可以有多个派生类

     一个派生类只能有一个超类-----------单一继承

   - 具有传递性

   - java规定：构造派生类之前必须先构造超类

     - 派生类的构造方法中若没有调用超类的构造方法，则默认super()调用超类的无参构造方法
     - 派生类的构造方法中若自己调用了超类的构造方法，则不再默认提供

     > super()调用超类构造方法，必须位于派生类构造方法的第一行

3. super：指代当前对象的超类对象

   super的用法：

   - super.成员变量名----------------------访问超类的成员变量(了解)
   - super.方法名()---------------------------调用超类的方法----------明天讲
   - super()-------------------------------------调用超类的构造方法

4. 向上造型：---------------------代码复用

   - 超类型的引用指向了派生类的对象
   - 能点出来什么，看引用的类型-----------这是规定，记住就OK了





补充：

1. 继承意味着代码虽然我没有写，但也属于我，只是没有写在一起而已
2. 泛化：将共有的抽出来的过程，泛化是设计层面的概念，从代码实现层面来说咱们就是继承，泛化就是继承
3. 继承要符合is a(是一个)的关系

